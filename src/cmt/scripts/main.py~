#!/usr/bin/env python
from __future__ import print_function
import roslib
#roslib.load_manifest('cmt')
import sys
import rospy
import cv2
from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from numpy import empty, nan
import os
import sys
import time
import CMT
import numpy as np
import util
import math

def rigid_transform_3D(A, B):
  #print 'Llamado'
  assert len(A) == len(B)

  N = A.shape[0]; # total points

  centroid_A = np.mean(A, axis=0)
  centroid_B = np.mean(B, axis=0)
  
  # centre the points
  AA = A - np.tile(centroid_A, (N, 1))
  BB = B - np.tile(centroid_B, (N, 1))

  # dot is matrix multiplication for array
  H = np.transpose(AA)* BB

  U, S, Vt = np.linalg.svd(H)

  R = Vt.T * U.T

  # special reflection case
  if np.linalg.det(R) < 0:
     #print "Reflection detected"
     Vt[2,:] *= -1
     R = Vt.T * U.T

  t = -R*centroid_A.T + centroid_B.T

  #print t

  return R, t

# Checks if a matrix is a valid rotation matrix.
def isRotationMatrix(R) :
    Rt = np.transpose(R)
    shouldBeIdentity = Rt*R
    print(shouldBeIdentity)
    I = np.identity(3, dtype = R.dtype)
    n = np.linalg.norm(I - shouldBeIdentity)
    return n < 1e-6

def rotationMatrixToEulerAngles(R) :
 
    #assert(isRotationMatrix(R))
     
    sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])
     
    singular = sy < 1e-6
 
    if  not singular :
        x = math.atan2(R[2,1] , R[2,2])
        y = math.atan2(-R[2,0], sy)
        z = math.atan2(R[1,0], R[0,0])
    else :
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0
 
    return np.array([x, y, z])

class image_converter:

  def __init__(self):
    self.image_pub = rospy.Publisher("image_topic_2",Image,queue_size=1)
    self.bridge = CvBridge()
    #self.image_sub = rospy.Subscriber("/usb_cam/image_raw",Image,self.callback)
    self.image_sub = rospy.Subscriber("/ocam/image_raw",Image,self.callback,queue_size=1)
    #self.image_sub = rospy.Subscriber("/usb2_cam/image_rect_color",Image,self.callback)
    self.CRT = CMT.CMT()
    


    self.CRT.estimate_scale = 'estimate_scale'
    self.CRT.estimate_rotation = 'estimate_rotation'
    self.pause_time = 10
    ###########################Primer Region
    
    im0 = cv2.imread('./frame_cap_m.jpg', flags=cv2.IMREAD_GRAYSCALE)
    #im0 = cv2.imread('./frame_cap3.jpg', flags=cv2.IMREAD_GRAYSCALE)#flags=cv2.IMREAD_GRAYSCALE)
    #im0 = cv2.imread('/home/sergio/catikin_ws_user/src/cmt/scripts/frame.jpg', flags=cv2.IMREAD_COLOR)
    #im0 = cv2.imread('/home/sergio/catikin_ws_user/src/cmt/scripts/frame.jpg',flags=cv2.IMREAD_GRAYSCALE)
    #cv2.imshow('im0', im0)
    #im_gray0 = cv2.cvtColor(im0, cv2.COLOR_BGR2GRAY)
    im_gray0=im0
    im_draw = np.copy(im0)
    print('Selecciona Primer Region')
    #tl=(84, 55) #talvez
    #br=(557, 307#tal vez
    #tl=(68, 68) 
    #br=(544, 316)
    #tl=(35,35)
    #bl=(605,325)
    tl=(78, 59) 
    br=(553, 297)

    (tl, br) = util.get_rect(im_draw)
    print('usando %i, %i como init bb', tl, br)
    self.CRT.initialise(im_gray0, tl, br)
    self.frame = 1
    self.conta=0
    



  def callback(self,data):
    try:
        tic = time.time()
        im_gray = self.bridge.imgmsg_to_cv2(data, "bgr8")
  
        # Read image
        #status, im = cap.read()
        #im=cv_image
        #im_gray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)
        #im_gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
        #im_draw = np.copy(cv_image)

        
        self.CRT.process_frame(im_gray)
        
	# Remember image
        im_prev = im_gray
        # Display results

        # Draw updated estimate
        if self.CRT.has_result:
          #cv2.line(im_gray, self.CRT.tl, self.CRT.tr, (255, 0, 0), 4)
          #cv2.line(im_gray, self.CRT.tr, self.CRT.br, (255, 0, 0), 4)
          #cv2.line(im_gray, self.CRT.br, self.CRT.bl, (255, 0, 0), 4)
          #cv2.line(im_gray, self.CRT.bl, self.CRT.tl, (255, 0, 0), 4)
          #font = cv2.FONT_HERSHEY_SIMPLEX
          #cv2.putText(im_gray,'1',(self.CRT.tl[0],self.CRT.tl[1]), font, 3, (200,255,155), 7, cv2.CV_AA)
          #cv2.putText(im_gray,'2',(self.CRT.tr[0],self.CRT.tr[1]), font, 3, (200,255,155), 7, cv2.CV_AA)
          #tl=(68, 68) #600cm=476pix
          #br=(544, 316)#300cm=248
          gk=1.2605042
          offs_x=320
          offs_y=180
          p1=[(self.CRT.tl[0]-offs_x)*gk,(self.CRT.tl[1]-offs_y)*gk,0]
          p2=[(self.CRT.tr[0]-offs_x)*gk,(self.CRT.tr[1]-offs_y)*gk,0]
          p3=[(self.CRT.bl[0]-offs_x)*gk, (self.CRT.bl[1]-offs_y)*gk,0]
          p4=[(self.CRT.br[0]-offs_x)*gk, (self.CRT.br[1]-offs_y)*gk,0]

          MCI=np.mat([p1,p2,p3,p4])
          MCR=np.mat([[-300,150,0],[300,150,0],[-300,-150,0],[300,-150,0]])
          ret_R, ret_t = rigid_transform_3D(MCI, MCR)
          vec_t=rotationMatrixToEulerAngles(ret_R)


          
        

        # Advance frame number
        self.frame += 1
        #print(self.CRT.tl[0])
        #print(self.CRT.tl[1])
        #print(self.CRT.tl.shape)
        

        try:
          #resized_image = cv2.resize(image, (100, 50)) 
          self.image_pub.publish(self.bridge.cv2_to_imgmsg(cv2.resize(im_draw, (150, 75)) , "bgr8"))
          toc = time.time()
          #print(1000 * (toc - tic))
          #print(ret_t[0,0],)
          print(ret_t[0,0],",",ret_t[1,0],",",vec_t[2]*180/3.1416,",",1000 * (toc - tic))
          #print(vec_t[2]*180/3.1416)
          #print(ret_t[0][0],",",ret_t[0][1],",",vec_t[0][2]*180/3.1416)
          #print(ret_t[0][0],",",ret_t[0][1],",",vec_t[2]*180/3.1416)
          #print('P',w[1])
          #print('P',w[2])
        except CvBridgeError as e:
          print(e)
    except CvBridgeError as e:
      print(e)

    

def main(args):
  ic = image_converter()
  rospy.init_node('image_converter', anonymous=True)
  try:
    rospy.spin()
  except KeyboardInterrupt:
    print("Shutting down")
  cv2.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)
